!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_NAME	hasktags
>->	src/Language/LLVC/Utils.hs	/^(>->) :: (a -> Either e b) -> (b -> c) -> a -> Either e c$/;"	ft	line:23
Arg	src/Language/LLVC/Types.hs	/^data Arg a $/;"	d	line:64
BareArg	src/Language/LLVC/Types.hs	/^type BareArg       = Arg       UX.SourceSpan $/;"	t	line:326
BareBody	src/Language/LLVC/Types.hs	/^type BareBody      = FnBody    UX.SourceSpan $/;"	t	line:329
BareDef	src/Language/LLVC/Types.hs	/^type BareDef       = FnDef     UX.SourceSpan $/;"	t	line:327
BareExpr	src/Language/LLVC/Types.hs	/^type BareExpr      = Expr      UX.SourceSpan $/;"	t	line:328
BareProgram	src/Language/LLVC/Types.hs	/^type BareProgram   = Program   UX.SourceSpan $/;"	t	line:324
BareStmt	src/Language/LLVC/Types.hs	/^type BareStmt      = Stmt      UX.SourceSpan $/;"	t	line:325
BareTypedArg	src/Language/LLVC/Types.hs	/^type BareTypedArg  = TypedArg  UX.SourceSpan $/;"	t	line:323
BareVar	src/Language/LLVC/Types.hs	/^type BareVar       = (Var,     UX.SourceSpan)$/;"	t	line:330
BvAnd	src/Language/LLVC/Types.hs	/^  | BvAnd $/;"	cons	line:273
BvOr	src/Language/LLVC/Types.hs	/^  | BvOr$/;"	cons	line:271
BvXor	src/Language/LLVC/Types.hs	/^  | BvXor$/;"	cons	line:272
Cmd	src/Language/LLVC/Smt.hs	/^data Cmd    = Say  !Smt $/;"	d	line:139
Context	src/Language/LLVC/Smt.hs	/^data Context = Ctx$/;"	d	line:241
Contract	src/Language/LLVC/Types.hs	/^data Contract = Ct$/;"	d	line:141
Ct	src/Language/LLVC/Types.hs	/^data Contract = Ct$/;"	d	line:141
Ctx	src/Language/LLVC/Smt.hs	/^data Context = Ctx$/;"	d	line:241
ECall	src/Language/LLVC/Types.hs	/^  = ECall Fn [TypedArg a] Type a -- ^ Function name, args, result type $/;"	d	line:72
ECon	src/Language/LLVC/Types.hs	/^  | ECon  !UX.Text       a    -- ^ smt-string-literal e.g. #x00000005$/;"	cons	line:68
ELit	src/Language/LLVC/Types.hs	/^  = ELit  !Integer       a    -- ^ integer $/;"	d	line:65
ETLit	src/Language/LLVC/Types.hs	/^  | ETLit !Integer !Type a    -- ^ integer interpreted at a type$/;"	cons	line:66
EVar	src/Language/LLVC/Types.hs	/^  | EVar  !Var           a    -- ^ variable $/;"	cons	line:67
Env	src/Language/LLVC/Verify.hs	/^type Env = M.HashMap Fn Contract $/;"	t	line:71
Eq	src/Language/LLVC/Types.hs	/^  | Eq$/;"	cons	line:275
Error	src/Language/LLVC/UX.hs	/^data UserError = Error$/;"	d	line:169
Expr	src/Language/LLVC/Types.hs	/^data Expr a $/;"	d	line:71
Fail	src/Language/LLVC/Smt.hs	/^  | Fail !UX.SourceSpan $/;"	cons	line:239
Float	src/Language/LLVC/Types.hs	/^  = Float $/;"	d	line:18
Fn	src/Language/LLVC/Types.hs	/^data Fn $/;"	d	line:31
FnBin	src/Language/LLVC/Types.hs	/^  | FnBin     Op           -- ^ binary operation $/;"	cons	line:33
FnBitcast	src/Language/LLVC/Types.hs	/^  | FnBitcast Type Type    -- ^ 'bitcast' $/;"	cons	line:35
FnBody	src/Language/LLVC/Types.hs	/^data FnBody a = FnBody $/;"	d	line:125
FnBody	src/Language/LLVC/Types.hs	/^data FnBody a = FnBody $/;"	d	line:125
FnCmp	src/Language/LLVC/Types.hs	/^  = FnCmp     Type Rel     -- ^ 'fcmp' olt $/;"	d	line:32
FnDef	src/Language/LLVC/Types.hs	/^data FnDef a = FnDef $/;"	d	line:131
FnDef	src/Language/LLVC/Types.hs	/^data FnDef a = FnDef $/;"	d	line:131
FnFunc	src/Language/LLVC/Types.hs	/^  | FnFunc    Var          -- ^ something that is 'call'ed $/;"	cons	line:36
FnSelect	src/Language/LLVC/Types.hs	/^  | FnSelect               -- ^ ternary 'select' $/;"	cons	line:34
FpAbs	src/Language/LLVC/Types.hs	/^  | FpAbs $/;"	cons	line:267
FpAdd	src/Language/LLVC/Types.hs	/^  | FpAdd $/;"	cons	line:269
FpEq	src/Language/LLVC/Types.hs	/^  = FpEq $/;"	d	line:266
FpLt	src/Language/LLVC/Types.hs	/^  | FpLt $/;"	cons	line:268
Hear	src/Language/LLVC/Smt.hs	/^            | Hear !Smt !UX.SourceSpan$/;"	cons	line:140
I	src/Language/LLVC/Types.hs	/^  | I Int                      -- ^ Int of a given size 1, 16, 32 etc.$/;"	cons	line:19
Ite	src/Language/LLVC/Types.hs	/^  | Ite $/;"	cons	line:274
Labeled	src/Language/LLVC/Types.hs	/^class Labeled thing where $/;"	c	line:177
Labeled	src/Language/LLVC/Types.hs	/^class Labeled thing where $/;"	c	line:177
Language.LLVC.Parse	src/Language/LLVC/Parse.hs	/^module Language.LLVC.Parse where -- ( parse, parseFile ) where$/;"	m	line:3
Language.LLVC.Smt	src/Language/LLVC/Smt.hs	/^module Language.LLVC.Smt $/;"	m	line:5
Language.LLVC.Types	src/Language/LLVC/Types.hs	/^module Language.LLVC.Types where $/;"	m	line:7
Language.LLVC.UX	src/Language/LLVC/UX.hs	/^module Language.LLVC.UX$/;"	m	line:7
Language.LLVC.Utils	src/Language/LLVC/Utils.hs	/^module Language.LLVC.Utils where$/;"	m	line:1
Language.LLVC.Verify	src/Language/LLVC/Verify.hs	/^module Language.LLVC.Verify (vcs) where $/;"	m	line:4
Lib	src/Lib.hs	/^module Lib$/;"	m	line:1
Located	src/Language/LLVC/UX.hs	/^class Located a where$/;"	c	line:54
Located	src/Language/LLVC/UX.hs	/^class Located a where$/;"	c	line:54
Ok	src/Language/LLVC/Smt.hs	/^  = Ok $/;"	d	line:238
Olt	src/Language/LLVC/Types.hs	/^  = Olt $/;"	d	line:40
Op	src/Language/LLVC/Types.hs	/^data Op $/;"	d	line:265
PAnd	src/Language/LLVC/Types.hs	/^  | PAnd   [Pred]$/;"	cons	line:300
PArg	src/Language/LLVC/Types.hs	/^  = PArg   !BareArg$/;"	d	line:297
PAtom	src/Language/LLVC/Types.hs	/^  | PAtom  !Op ![Pred] $/;"	cons	line:298
PNot	src/Language/LLVC/Types.hs	/^  | PNot   !Pred $/;"	cons	line:299
POr	src/Language/LLVC/Types.hs	/^  | POr    [Pred]$/;"	cons	line:301
PPrint	src/Language/LLVC/UX.hs	/^class PPrint a where$/;"	c	line:48
PPrint	src/Language/LLVC/UX.hs	/^class PPrint a where$/;"	c	line:48
PTrue	src/Language/LLVC/Types.hs	/^  | PTrue $/;"	cons	line:302
Parser	src/Language/LLVC/Parse.hs	/^type Parser = Parsec SourcePos Text$/;"	t	line:15
Phase	src/Language/LLVC/Utils.hs	/^data Phase = Start | Stop deriving (Show)$/;"	d	line:64
Pred	src/Language/LLVC/Types.hs	/^data Pred $/;"	d	line:296
Program	src/Language/LLVC/Types.hs	/^type Program a = M.HashMap Var (FnDef a)  -- ^ A list of function declarations$/;"	t	line:118
Rel	src/Language/LLVC/Types.hs	/^data Rel $/;"	d	line:39
Response	src/Language/LLVC/Smt.hs	/^data Response $/;"	d	line:237
Result	src/Language/LLVC/UX.hs	/^type Result a = Either [UserError] a$/;"	t	line:164
SAsgn	src/Language/LLVC/Types.hs	/^  = SAsgn   !Var (Expr a) a          -- ^ Assignments for each variable$/;"	d	line:121
SAssert	src/Language/LLVC/Types.hs	/^  | SAssert !Pred         a          -- ^ Assertion to be checked at a point.$/;"	cons	line:122
SS	src/Language/LLVC/UX.hs	/^data SourceSpan = SS$/;"	d	line:63
Say	src/Language/LLVC/Smt.hs	/^data Cmd    = Say  !Smt $/;"	d	line:139
Slt	src/Language/LLVC/Types.hs	/^  | Slt  $/;"	cons	line:41
Smt	src/Language/LLVC/Smt.hs	/^type    Smt = UX.Text$/;"	t	line:137
SmtOp	src/Language/LLVC/Types.hs	/^  | SmtOp !Var$/;"	cons	line:276
SourceSpan	src/Language/LLVC/UX.hs	/^data SourceSpan = SS$/;"	d	line:63
Start	src/Language/LLVC/Utils.hs	/^data Phase = Start | Stop deriving (Show)$/;"	d	line:64
Stmt	src/Language/LLVC/Types.hs	/^data Stmt a $/;"	d	line:120
Stop	src/Language/LLVC/Utils.hs	/^data Phase = Start | Stop deriving (Show)$/;"	cons	line:64
Text	src/Language/LLVC/UX.hs	/^type Text = String$/;"	t	line:46
ToFp32	src/Language/LLVC/Types.hs	/^  | ToFp32    -- ((_ to_fp 8 24) RNE r3)  $/;"	cons	line:270
ToSmt	src/Language/LLVC/Smt.hs	/^class ToSmt a where $/;"	c	line:57
ToSmt	src/Language/LLVC/Smt.hs	/^class ToSmt a where $/;"	c	line:57
Type	src/Language/LLVC/Types.hs	/^data Type $/;"	d	line:17
TypedArg	src/Language/LLVC/Types.hs	/^type TypedArg  a = (Type, Arg  a)$/;"	t	line:75
TypedExpr	src/Language/LLVC/Types.hs	/^type TypedExpr a = (Type, Expr a)$/;"	t	line:76
UserError	src/Language/LLVC/UX.hs	/^data UserError = Error$/;"	d	line:169
VC	src/Language/LLVC/Smt.hs	/^newtype VC  = VC [Cmd] $/;"	nt	line:138
VC	src/Language/LLVC/Smt.hs	/^newtype VC  = VC [Cmd] $/;"	cons	line:138
Var	src/Language/LLVC/Types.hs	/^type Var   = UX.Text $/;"	t	line:26
a	src/Language/LLVC/Types.hs	/^type TypedArg  a = (Type, Arg  a)$/;"	fi	line:75
a	src/Language/LLVC/UX.hs	/^type Result a = Either [UserError] a$/;"	fi	line:164
abort	src/Language/LLVC/UX.hs	/^abort :: UserError -> b$/;"	ft	line:193
abort	src/Language/LLVC/UX.hs	/^abort e = throw [e]$/;"	fi	line:195
annotationP	src/Language/LLVC/Parse.hs	/^annotationP :: String -> Parser Pred$/;"	ft	line:83
annotationP	src/Language/LLVC/Parse.hs	/^annotationP kw = symbol ";@" >> rWord kw >> predP$/;"	fi	line:84
argP	src/Language/LLVC/Parse.hs	/^argP :: Parser BareArg $/;"	ft	line:115
argP	src/Language/LLVC/Parse.hs	/^argP $/;"	fi	line:116
argTypeP	src/Language/LLVC/Parse.hs	/^argTypeP :: Parser (Var, Type)$/;"	ft	line:86
argTypeP	src/Language/LLVC/Parse.hs	/^argTypeP = do $/;"	fi	line:87
argTypesP	src/Language/LLVC/Parse.hs	/^argTypesP :: Parser [(Var, Type)] $/;"	ft	line:105
argTypesP	src/Language/LLVC/Parse.hs	/^argTypesP = parens (sepBy argTypeP comma) $/;"	fi	line:106
assert	src/Language/LLVC/Smt.hs	/^assert :: (UX.Located l) => l -> Pred -> VC $/;"	ft	line:156
assert	src/Language/LLVC/Smt.hs	/^assert _ PTrue = mempty $/;"	fi	line:157
atom1	src/Language/LLVC/Parse.hs	/^atom1 :: Text -> Op -> Parser Pred $/;"	ft	line:225
atom1	src/Language/LLVC/Parse.hs	/^atom1 kw o = (\\x1 -> PAtom o [x1]) $/;"	fi	line:226
atom2	src/Language/LLVC/Parse.hs	/^atom2 :: Text -> Op -> Parser Pred $/;"	ft	line:229
atom2	src/Language/LLVC/Parse.hs	/^atom2 kw o = (\\x1 x2 -> PAtom o [x1, x2]) $/;"	fi	line:230
atom3	src/Language/LLVC/Parse.hs	/^atom3 :: Text -> Op -> Parser Pred $/;"	ft	line:234
atom3	src/Language/LLVC/Parse.hs	/^atom3 kw o = (\\x1 x2 x3 -> PAtom o [x1, x2, x3]) $/;"	fi	line:235
atomOp	src/Language/LLVC/Parse.hs	/^atomOp :: Parser Pred $/;"	ft	line:222
atomOp	src/Language/LLVC/Parse.hs	/^atomOp = PAtom <$> (SmtOp . fst <$> smtId) <*> many pArgP $/;"	fi	line:223
attrP	src/Language/LLVC/Parse.hs	/^attrP :: Parser () $/;"	ft	line:57
attrP	src/Language/LLVC/Parse.hs	/^attrP = symbol "#" >> integer >> return ()$/;"	fi	line:58
attribDef	src/Language/LLVC/Parse.hs	/^attribDef :: Parser ()$/;"	ft	line:48
attribDef	src/Language/LLVC/Parse.hs	/^attribDef = attrP >> symbol "=" >> braces (many attributeP) >> return ()$/;"	fi	line:49
betweenS	src/Language/LLVC/Parse.hs	/^betweenS :: String -> String -> Parser a -> Parser a$/;"	ft	line:282
betweenS	src/Language/LLVC/Parse.hs	/^betweenS l r = between (symbol l) (symbol r)$/;"	fi	line:283
binExprP	src/Language/LLVC/Parse.hs	/^binExprP :: Parser BareExpr$/;"	ft	line:133
binExprP	src/Language/LLVC/Parse.hs	/^binExprP = do $/;"	fi	line:134
bitcastP	src/Language/LLVC/Parse.hs	/^bitcastP :: Parser BareExpr $/;"	ft	line:147
bitcastP	src/Language/LLVC/Parse.hs	/^bitcastP = do $/;"	fi	line:148
bodyP	src/Language/LLVC/Parse.hs	/^bodyP :: Parser BareBody$/;"	ft	line:92
bodyP	src/Language/LLVC/Parse.hs	/^bodyP = FnBody <$> many stmtP <*> retP $/;"	fi	line:93
braces	src/Language/LLVC/Parse.hs	/^braces :: Parser a -> Parser a$/;"	ft	line:279
braces	src/Language/LLVC/Parse.hs	/^braces = betweenS "{" "}"$/;"	fi	line:280
brackets	src/Language/LLVC/Parse.hs	/^brackets :: Parser a -> Parser a$/;"	ft	line:275
brackets	src/Language/LLVC/Parse.hs	/^brackets = betweenS "[" "]"$/;"	fi	line:276
check	src/Language/LLVC/Smt.hs	/^check :: (UX.Located l) => l -> Pred -> VC $/;"	ft	line:160
check	src/Language/LLVC/Smt.hs	/^check _ PTrue = mempty $/;"	fi	line:161
checkId	src/Language/LLVC/Parse.hs	/^checkId :: Text -> Parser Text$/;"	ft	line:340
checkSat	src/Language/LLVC/Smt.hs	/^checkSat :: UX.SourceSpan -> VC$/;"	ft	line:173
checkSat	src/Language/LLVC/Smt.hs	/^checkSat l = VC [ Hear "(check-sat)" l ]$/;"	fi	line:174
cmpP	src/Language/LLVC/Parse.hs	/^cmpP :: Parser BareExpr $/;"	ft	line:166
cmpP	src/Language/LLVC/Parse.hs	/^cmpP = do $/;"	fi	line:167
colon	src/Language/LLVC/Parse.hs	/^colon :: Parser String$/;"	ft	line:267
colon	src/Language/LLVC/Parse.hs	/^colon = symbol ":"$/;"	fi	line:268
comma	src/Language/LLVC/Parse.hs	/^comma :: Parser String$/;"	ft	line:264
comma	src/Language/LLVC/Parse.hs	/^comma = symbol ","$/;"	fi	line:265
command	src/Language/LLVC/Smt.hs	/^command              :: Context -> Cmd -> IO Response$/;"	ft	line:220
command	src/Language/LLVC/Smt.hs	/^command me !cmd     = say cmd >> hear cmd$/;"	fi	line:222
comment	src/Language/LLVC/Smt.hs	/^comment :: UX.Text -> VC $/;"	ft	line:150
comment	src/Language/LLVC/Smt.hs	/^comment s = say $ printf "; %s" s$/;"	fi	line:151
contract	src/Language/LLVC/Types.hs	/^contract :: [Var] -> Pred -> Pred -> Contract $/;"	ft	line:230
contract	src/Language/LLVC/Types.hs	/^contract xs pre post = Ct $/;"	fi	line:231
contract	src/Language/LLVC/Verify.hs	/^contract :: Env -> Fn -> SourceSpan -> Contract$/;"	ft	line:73
contract	src/Language/LLVC/Verify.hs	/^contract env fn l = Mb.fromMaybe err (M.lookup fn env)$/;"	fi	line:74
contractAt	src/Language/LLVC/Verify.hs	/^contractAt :: (Located a) => Env -> Fn -> Var -> [TypedArg a] -> a -> (Pred, Pred)$/;"	ft	line:50
contractAt	src/Language/LLVC/Verify.hs	/^contractAt env fn rv tys l = (pre, post) $/;"	fi	line:51
convTable	src/Language/LLVC/Smt.hs	/^convTable :: M.HashMap (Integer, Type) String$/;"	ft	line:88
convTable	src/Language/LLVC/Smt.hs	/^convTable = M.fromList $/;"	fi	line:89
ctParams	src/Language/LLVC/Types.hs	/^  { ctParams :: ![Var]               -- ^ Parameter names $/;"	c_a	line:142
ctPost	src/Language/LLVC/Types.hs	/^  , ctPost   :: !Pred                -- ^ Postcondition \/ "ensures" clause               $/;"	c_a	line:144
ctPre	src/Language/LLVC/Types.hs	/^  , ctPre    :: !Pred                -- ^ Precondition \/ "requires" clause               $/;"	c_a	line:143
ctxCin	src/Language/LLVC/Smt.hs	/^  , ctxCin     :: !Handle$/;"	c_a	line:243
ctxCout	src/Language/LLVC/Smt.hs	/^  , ctxCout    :: !Handle$/;"	c_a	line:244
ctxLog	src/Language/LLVC/Smt.hs	/^  , ctxLog     :: !(Maybe Handle)$/;"	c_a	line:245
ctxPid	src/Language/LLVC/Smt.hs	/^  { ctxPid     :: !ProcessHandle$/;"	c_a	line:242
cursorLine	src/Language/LLVC/UX.hs	/^cursorLine :: Int -> String -> String$/;"	ft	line:142
cursorLine	src/Language/LLVC/UX.hs	/^cursorLine l s = printf "%s|  %s" (lineString l) s$/;"	fi	line:143
decl	src/Language/LLVC/Types.hs	/^decl :: Var -> [Type] -> Type -> Pred -> Pred -> a -> FnDef a $/;"	ft	line:219
decl	src/Language/LLVC/Types.hs	/^decl f ts t pre post l = FnDef $/;"	fi	line:220
declare	src/Language/LLVC/Smt.hs	/^declare :: (UX.Located l) => l -> (Var, Type) -> VC $/;"	ft	line:153
declare	src/Language/LLVC/Smt.hs	/^declare _ (x, t) = say $ printf "(declare-const %s %s)" (toSmt x) (toSmt t)$/;"	fi	line:154
declareP	src/Language/LLVC/Parse.hs	/^declareP :: Parser BareDef $/;"	ft	line:61
declareP	src/Language/LLVC/Parse.hs	/^declareP = do $/;"	fi	line:62
defineP	src/Language/LLVC/Parse.hs	/^defineP :: Parser BareDef $/;"	ft	line:70
defineP	src/Language/LLVC/Parse.hs	/^defineP = do $/;"	fi	line:71
defn	src/Language/LLVC/Types.hs	/^defn :: Var -> [(Var, Type)] -> FnBody a -> Type -> Pred -> Pred -> a -> FnDef a $/;"	ft	line:238
defn	src/Language/LLVC/Types.hs	/^defn f xts b t pre post l = FnDef $/;"	fi	line:239
dupBy	src/Language/LLVC/Utils.hs	/^dupBy :: (Ord k) => (a -> k) -> [a] -> [[a]]$/;"	ft	line:43
dupBy	src/Language/LLVC/Utils.hs	/^dupBy f xs = [ xs' | (_, xs') <- groupBy f xs, 2 <= length xs' ]$/;"	fi	line:44
eCallP	src/Language/LLVC/Parse.hs	/^eCallP :: Parser BareExpr $/;"	ft	line:180
eCallP	src/Language/LLVC/Parse.hs	/^eCallP = do $/;"	fi	line:181
eMsg	src/Language/LLVC/UX.hs	/^  { eMsg  :: !Text$/;"	c_a	line:170
eSpan	src/Language/LLVC/UX.hs	/^  , eSpan :: !SourceSpan$/;"	c_a	line:171
elem	src/Language/LLVC/Parse.hs	/^  | x `elem` keywords = fail $ "keyword " ++ show x ++ " cannot be an identifier"$/;"	fi	line:342
ensurePath	src/Language/LLVC/Utils.hs	/^ensurePath :: FilePath -> IO ()$/;"	ft	line:72
ensurePath	src/Language/LLVC/Utils.hs	/^ensurePath = createDirectoryIfMissing True . takeDirectory$/;"	fi	line:73
ensuresP	src/Language/LLVC/Parse.hs	/^requiresP, ensuresP :: Parser Pred$/;"	ft	line:79
ensuresP	src/Language/LLVC/Parse.hs	/^ensuresP  = annotationP "ensures"$/;"	fi	line:81
executeShellCommand	src/Language/LLVC/Utils.hs	/^executeShellCommand :: Maybe FilePath -> String -> Int -> IO ExitCode$/;"	ft	line:52
executeShellCommand	src/Language/LLVC/Utils.hs	/^executeShellCommand logMb cmd n = fromMaybe (ExitFailure 100) <$> body$/;"	fi	line:53
exprP	src/Language/LLVC/Parse.hs	/^exprP :: Parser BareExpr $/;"	ft	line:124
exprP	src/Language/LLVC/Parse.hs	/^exprP $/;"	fi	line:125
f	src/Language/LLVC/Utils.hs	/^f >-> g = f >=> safe g$/;"	fi	line:25
fnArgTys	src/Language/LLVC/Types.hs	/^fnArgTys    :: FnDef a -> [(Var, Type)]$/;"	ft	line:155
fnArgTys	src/Language/LLVC/Types.hs	/^fnArgTys fd = zip (ctParams (fnCon fd)) (fnArgs fd)$/;"	fi	line:156
fnArgs	src/Language/LLVC/Types.hs	/^  , fnArgs :: ![Type]                -- ^ Parameters and their types $/;"	c_a	line:133
fnBody	src/Language/LLVC/Types.hs	/^  , fnBody :: Maybe (FnBody a)       -- ^ 'Nothing' for 'declare', 'Just fb' for 'define' $/;"	c_a	line:136
fnCon	src/Language/LLVC/Types.hs	/^  , fnCon  :: !Contract              -- ^ Specification $/;"	c_a	line:135
fnDefnP	src/Language/LLVC/Parse.hs	/^fnDefnP :: Parser (Maybe BareDef) $/;"	ft	line:41
fnDefnP	src/Language/LLVC/Parse.hs	/^fnDefnP $/;"	fi	line:42
fnLab	src/Language/LLVC/Types.hs	/^  , fnLab  :: a                     $/;"	c_a	line:137
fnName	src/Language/LLVC/Types.hs	/^  { fnName :: !Var                   -- ^ Name$/;"	c_a	line:132
fnOut	src/Language/LLVC/Types.hs	/^  , fnOut  :: !Type                  -- ^ Output type $/;"	c_a	line:134
fnRet	src/Language/LLVC/Types.hs	/^  , fnRet   :: !(TypedArg a)         -- ^ Return value$/;"	c_a	line:127
fnStmts	src/Language/LLVC/Types.hs	/^  { fnStmts :: ![Stmt a]             -- ^ Statements $/;"	c_a	line:126
getLabel	src/Language/LLVC/Types.hs	/^  getLabel :: thing a -> a $/;"	ft	line:178
getRange	src/Language/LLVC/Utils.hs	/^getRange :: Int -> Int -> [a] -> [a]$/;"	ft	line:88
getRange	src/Language/LLVC/Utils.hs	/^getRange i1 i2$/;"	fi	line:89
getSpan	src/Language/LLVC/UX.hs	/^getSpan :: SourceSpan -> String -> String$/;"	ft	line:113
getSpan	src/Language/LLVC/UX.hs	/^getSpan sp$/;"	fi	line:114
getSpanMulti	src/Language/LLVC/UX.hs	/^getSpanMulti :: Int -> Int -> String -> String$/;"	ft	line:127
getSpanMulti	src/Language/LLVC/UX.hs	/^getSpanMulti l1 l2$/;"	fi	line:128
getSpanSingle	src/Language/LLVC/UX.hs	/^getSpanSingle :: Int -> Int -> Int -> String -> String$/;"	ft	line:120
getSpanSingle	src/Language/LLVC/UX.hs	/^getSpanSingle l c1 c2$/;"	fi	line:121
groupBy	src/Language/LLVC/Utils.hs	/^groupBy :: (Ord k) => (a -> k) -> [a] -> [(k, [a])]$/;"	ft	line:37
groupBy	src/Language/LLVC/Utils.hs	/^groupBy f = M.toList . L.foldl' (\\m x -> inserts (f x) x m) M.empty$/;"	fi	line:38
hPutStrLnNow	src/Language/LLVC/Smt.hs	/^hPutStrLnNow     :: Handle -> T.Text -> IO ()$/;"	ft	line:215
hPutStrLnNow	src/Language/LLVC/Smt.hs	/^hPutStrLnNow h !s = TIO.hPutStrLn h s >> hFlush h$/;"	fi	line:216
handleIO	src/Language/LLVC/Utils.hs	/^handleIO :: FilePath -> IOException -> IO (Either String a)$/;"	ft	line:78
handleIO	src/Language/LLVC/Utils.hs	/^handleIO f e = return . Left $ "Warning: Couldn't open " <> f <> ": " <> show e$/;"	fi	line:79
highlight	src/Language/LLVC/UX.hs	/^highlight :: Int -> Int -> Int -> String -> String$/;"	ft	line:133
highlight	src/Language/LLVC/UX.hs	/^highlight l c1 c2 s = unlines$/;"	fi	line:134
highlights	src/Language/LLVC/UX.hs	/^highlights :: Int -> [String] -> String$/;"	ft	line:139
highlights	src/Language/LLVC/UX.hs	/^highlights i ls = unlines $ L.zipWith cursorLine [i..] ls$/;"	fi	line:140
identChar	src/Language/LLVC/Parse.hs	/^identChar :: Parser Char$/;"	ft	line:345
identChar	src/Language/LLVC/Parse.hs	/^identChar = oneOf ok <?> "identifier-char"$/;"	fi	line:346
identifier	src/Language/LLVC/Parse.hs	/^identifier :: Text -> Parser (String, SourceSpan)$/;"	ft	line:330
identifier	src/Language/LLVC/Parse.hs	/^identifier s = lexeme (p >>= checkId)$/;"	fi	line:331
inserts	src/Language/LLVC/Utils.hs	/^inserts :: (Ord k) => k -> v -> M.Map k [v] -> M.Map k [v]$/;"	ft	line:40
inserts	src/Language/LLVC/Utils.hs	/^inserts k v m = M.insert k (v : M.findWithDefault [] k m) m$/;"	fi	line:41
instance	src/Language/LLVC/Smt.hs	/^instance ToSmt VC where $/;"	fi	line:60
instance	src/Language/LLVC/Types.hs	/^instance UX.PPrint Type where $/;"	fi	line:22
instance	src/Language/LLVC/UX.hs	/^instance Located SourceSpan where$/;"	fi	line:57
integer	src/Language/LLVC/Parse.hs	/^integer :: Parser (Integer, SourceSpan)$/;"	ft	line:290
integer	src/Language/LLVC/Parse.hs	/^integer = lexeme (   (symbol "0x" *> L.hexadecimal) $/;"	fi	line:292
integerBinary	src/Language/LLVC/Utils.hs	/^integerBinary :: Integer -> String $/;"	ft	line:96
integerBinary	src/Language/LLVC/Utils.hs	/^integerBinary i = showIntAtBase 2 intToDigit i "" $/;"	fi	line:97
integerHex	src/Language/LLVC/Utils.hs	/^integerHex :: Integer -> String $/;"	ft	line:93
integerHex	src/Language/LLVC/Utils.hs	/^integerHex i = showHex i "" $/;"	fi	line:94
junkSpan	src/Language/LLVC/UX.hs	/^junkSpan :: SourceSpan$/;"	ft	line:158
junkSpan	src/Language/LLVC/UX.hs	/^junkSpan = posSpan (initialPos "unknown")$/;"	fi	line:159
keywords	src/Language/LLVC/Parse.hs	/^keywords :: [Text]$/;"	ft	line:301
keywords	src/Language/LLVC/Parse.hs	/^keywords =$/;"	fi	line:302
lexeme	src/Language/LLVC/Parse.hs	/^lexeme :: Parser a -> Parser (a, SourceSpan)$/;"	ft	line:286
lexeme	src/Language/LLVC/Parse.hs	/^lexeme p = L.lexeme sc (withSpan p)$/;"	fi	line:287
lineString	src/Language/LLVC/UX.hs	/^lineString :: Int -> String$/;"	ft	line:145
lineString	src/Language/LLVC/UX.hs	/^lineString n = replicate (10 - nD) ' ' ++ nS$/;"	fi	line:146
llOpP	src/Language/LLVC/Parse.hs	/^llOpP :: Parser (Op, SourceSpan) $/;"	ft	line:140
llOpP	src/Language/LLVC/Parse.hs	/^llOpP =   (BvAnd, ) <$> rWord "and" $/;"	fi	line:141
makeContext	src/Language/LLVC/Smt.hs	/^makeContext :: FilePath -> IO Context$/;"	ft	line:186
makeContext	src/Language/LLVC/Smt.hs	/^makeContext f = do $/;"	fi	line:187
makeProcess	src/Language/LLVC/Smt.hs	/^makeProcess :: IO Context$/;"	ft	line:228
makeProcess	src/Language/LLVC/Smt.hs	/^makeProcess = do $/;"	fi	line:229
mappendSpan	src/Language/LLVC/UX.hs	/^mappendSpan :: SourceSpan -> SourceSpan -> SourceSpan$/;"	ft	line:73
mappendSpan	src/Language/LLVC/UX.hs	/^mappendSpan s1 s2$/;"	fi	line:74
mconcatMap	src/Language/LLVC/Utils.hs	/^mconcatMap :: (Monoid b) => (a -> b) -> [a] -> b $/;"	ft	line:31
mconcatMap	src/Language/LLVC/Utils.hs	/^mconcatMap f = mconcat . fmap f$/;"	fi	line:33
mkBitcast	src/Language/LLVC/Types.hs	/^mkBitcast :: TypedArg a -> Type -> a -> Expr a $/;"	ft	line:208
mkBitcast	src/Language/LLVC/Types.hs	/^mkBitcast (t, e) t' = ECall (FnBitcast t t') [(t, e)] t'$/;"	fi	line:209
mkCall	src/Language/LLVC/Types.hs	/^mkCall :: Var -> [(Var, Type)] -> Type -> a -> Expr a $/;"	ft	line:214
mkCall	src/Language/LLVC/Types.hs	/^mkCall f xts t sp = ECall (FnFunc f) tes t sp$/;"	fi	line:215
mkCmp	src/Language/LLVC/Types.hs	/^mkCmp :: Rel -> Type -> Arg a -> Arg a -> a -> Expr a $/;"	ft	line:196
mkCmp	src/Language/LLVC/Types.hs	/^mkCmp r t e1 e2 = ECall (FnCmp t r) [tLit (t, e1), tLit (t, e2)] (I 1)$/;"	fi	line:197
mkContract	src/Language/LLVC/Verify.hs	/^mkContract :: Int -> Text -> Text -> Contract $/;"	ft	line:124
mkContract	src/Language/LLVC/Verify.hs	/^mkContract n tPre tPost = Ct $/;"	fi	line:125
mkEnv	src/Language/LLVC/Verify.hs	/^mkEnv :: Program a -> Env $/;"	ft	line:79
mkEnv	src/Language/LLVC/Verify.hs	/^mkEnv p   = M.fromList (prims ++ defs) $/;"	fi	line:80
mkError	src/Language/LLVC/UX.hs	/^mkError :: Text -> SourceSpan -> UserError$/;"	ft	line:198
mkError	src/Language/LLVC/UX.hs	/^mkError = Error$/;"	fi	line:200
mkOp	src/Language/LLVC/Types.hs	/^mkOp :: Op -> TypedArg a -> Arg a -> a -> Expr a $/;"	ft	line:211
mkOp	src/Language/LLVC/Types.hs	/^mkOp o (t, e1) e2 = ECall (FnBin o) [tLit (t, e1), tLit (t, e2)] t $/;"	fi	line:212
mkSelect	src/Language/LLVC/Types.hs	/^mkSelect :: (Show a) => TypedArg a -> TypedArg a -> TypedArg a -> a -> Expr a $/;"	ft	line:199
mkSelect	src/Language/LLVC/Types.hs	/^mkSelect x@(t1, _) y@(t2, _) z@(t3, _) l $/;"	fi	line:200
pArgP	src/Language/LLVC/Parse.hs	/^pArgP :: Parser Pred $/;"	ft	line:240
pArgP	src/Language/LLVC/Parse.hs	/^pArgP =  PArg <$> argP $/;"	fi	line:241
pAtomP	src/Language/LLVC/Parse.hs	/^pAtomP :: Parser Pred $/;"	ft	line:208
pAtomP	src/Language/LLVC/Parse.hs	/^pAtomP $/;"	fi	line:209
panic	src/Language/LLVC/UX.hs	/^panic :: String -> SourceSpan -> a$/;"	ft	line:188
panic	src/Language/LLVC/UX.hs	/^panic msg sp = throw [Error msg sp]$/;"	fi	line:190
paramVar	src/Language/LLVC/Types.hs	/^paramVar :: Int -> Var $/;"	ft	line:253
paramVar	src/Language/LLVC/Types.hs	/^paramVar i = "%arg" ++ show i $/;"	fi	line:254
paramVars	src/Language/LLVC/Types.hs	/^paramVars :: [Var]$/;"	ft	line:250
paramVars	src/Language/LLVC/Types.hs	/^paramVars = paramVar <$> [0..] $/;"	fi	line:251
parens	src/Language/LLVC/Parse.hs	/^parens :: Parser a -> Parser a$/;"	ft	line:271
parens	src/Language/LLVC/Parse.hs	/^parens = betweenS "(" ")"$/;"	fi	line:272
parse	src/Language/LLVC/Parse.hs	/^parse :: FilePath -> Text -> BareProgram $/;"	ft	line:23
parse	src/Language/LLVC/Parse.hs	/^parse = parseWith programP$/;"	fi	line:25
parseFile	src/Language/LLVC/Parse.hs	/^parseFile :: FilePath -> IO BareProgram $/;"	ft	line:18
parseFile	src/Language/LLVC/Parse.hs	/^parseFile f = parse f <$> readFile f$/;"	fi	line:20
parseWith	src/Language/LLVC/Parse.hs	/^parseWith  :: Parser a -> FilePath -> Text -> a$/;"	ft	line:27
parseWith	src/Language/LLVC/Parse.hs	/^parseWith p f s = case runParser (whole p) f s of$/;"	fi	line:28
phase	src/Language/LLVC/Utils.hs	/^phase :: Phase -> String -> IO ()$/;"	ft	line:66
phase	src/Language/LLVC/Utils.hs	/^phase p msg = putStrLn $ printf "**** %s : %s **************************************" (show p) msg$/;"	fi	line:67
pop	src/Language/LLVC/Smt.hs	/^push, pop :: VC $/;"	ft	line:169
pop	src/Language/LLVC/Smt.hs	/^pop      = say  "(pop 1)"$/;"	fi	line:171
posSpan	src/Language/LLVC/UX.hs	/^posSpan :: SourcePos -> SourceSpan$/;"	ft	line:154
posSpan	src/Language/LLVC/UX.hs	/^posSpan p = SS p p$/;"	fi	line:156
postCond	src/Language/LLVC/Verify.hs	/^postCond :: Int -> Text -> Contract $/;"	ft	line:121
postCond	src/Language/LLVC/Verify.hs	/^postCond n = mkContract n "true" $/;"	fi	line:122
ppCall	src/Language/LLVC/Types.hs	/^ppCall :: Fn -> [TypedArg a] -> Type -> UX.Text $/;"	ft	line:92
ppCall	src/Language/LLVC/Types.hs	/^ppCall (FnFunc f) tes t   $/;"	fi	line:93
ppCmp	src/Language/LLVC/Types.hs	/^ppCmp :: Type -> Rel -> UX.Text $/;"	ft	line:87
ppCmp	src/Language/LLVC/Types.hs	/^ppCmp Float Olt = "fcmp olt"$/;"	fi	line:88
ppSourceSpan	src/Language/LLVC/UX.hs	/^ppSourceSpan :: SourceSpan -> String$/;"	ft	line:82
ppSourceSpan	src/Language/LLVC/UX.hs	/^ppSourceSpan s$/;"	fi	line:83
pprint	src/Language/LLVC/UX.hs	/^  pprint :: a -> Text$/;"	ft	line:49
pprints	src/Language/LLVC/Types.hs	/^pprints :: (UX.PPrint a) => [a] -> UX.Text$/;"	ft	line:110
pprints	src/Language/LLVC/Types.hs	/^pprints = L.intercalate ", " . fmap UX.pprint $/;"	fi	line:111
pred	src/Language/LLVC/Verify.hs	/^pred :: Text -> Pred $/;"	ft	line:132
pred	src/Language/LLVC/Verify.hs	/^pred = Parse.parseWith Parse.predP "primitive-contracts" $/;"	fi	line:133
pred0P	src/Language/LLVC/Parse.hs	/^pred0P :: Parser Pred $/;"	ft	line:202
pred0P	src/Language/LLVC/Parse.hs	/^pred0P =  PAnd        <$> (rWord "and" *> many predP)$/;"	fi	line:203
predP	src/Language/LLVC/Parse.hs	/^predP :: Parser Pred $/;"	ft	line:196
predP	src/Language/LLVC/Parse.hs	/^predP =  parens pred0P $/;"	fi	line:197
primitiveContracts	src/Language/LLVC/Verify.hs	/^primitiveContracts :: [(Fn, Contract)]$/;"	ft	line:86
primitiveContracts	src/Language/LLVC/Verify.hs	/^primitiveContracts =  $/;"	fi	line:87
programP	src/Language/LLVC/Parse.hs	/^programP :: Parser BareProgram $/;"	ft	line:36
programP	src/Language/LLVC/Parse.hs	/^programP = do $/;"	fi	line:37
push	src/Language/LLVC/Smt.hs	/^push, pop :: VC $/;"	ft	line:169
push	src/Language/LLVC/Smt.hs	/^push     = say  "(push 1)"$/;"	fi	line:170
rWord	src/Language/LLVC/Parse.hs	/^rWord   :: String -> Parser SourceSpan$/;"	ft	line:297
rWord	src/Language/LLVC/Parse.hs	/^rWord w = snd <$> (withSpan (string w) <* notFollowedBy alphaNumChar <* sc)$/;"	fi	line:298
readFileSpan	src/Language/LLVC/UX.hs	/^readFileSpan :: SourceSpan -> IO String$/;"	ft	line:101
readFileSpan	src/Language/LLVC/UX.hs	/^readFileSpan sp = do $/;"	fi	line:103
readPrelude	src/Language/LLVC/Smt.hs	/^readPrelude :: IO UX.Text $/;"	ft	line:50
readPrelude	src/Language/LLVC/Smt.hs	/^readPrelude = readFile =<< Paths_llvc.getDataFileName "include\/prelude.smt2"$/;"	fi	line:51
relP	src/Language/LLVC/Parse.hs	/^relP :: Parser Rel $/;"	ft	line:175
relP	src/Language/LLVC/Parse.hs	/^relP =  (rWord "olt" >> return Olt)$/;"	fi	line:176
renderError	src/Language/LLVC/UX.hs	/^renderError :: UserError -> IO Text$/;"	ft	line:207
renderError	src/Language/LLVC/UX.hs	/^renderError e = do$/;"	fi	line:208
renderErrors	src/Language/LLVC/UX.hs	/^renderErrors :: [UserError] -> IO Text$/;"	ft	line:202
renderErrors	src/Language/LLVC/UX.hs	/^renderErrors es = do$/;"	fi	line:203
requiresP	src/Language/LLVC/Parse.hs	/^requiresP, ensuresP :: Parser Pred$/;"	ft	line:79
requiresP	src/Language/LLVC/Parse.hs	/^requiresP = annotationP "requires"$/;"	fi	line:80
retP	src/Language/LLVC/Parse.hs	/^retP :: Parser (Type, BareArg)$/;"	ft	line:108
retP	src/Language/LLVC/Parse.hs	/^retP = do $/;"	fi	line:109
retVar	src/Language/LLVC/Types.hs	/^retVar :: Var $/;"	ft	line:256
retVar	src/Language/LLVC/Types.hs	/^retVar = "%ret"$/;"	fi	line:257
runQuery	src/Language/LLVC/Smt.hs	/^runQuery :: VC -> IO [UX.SourceSpan]$/;"	ft	line:183
runQuery	src/Language/LLVC/Smt.hs	/^runQuery = error "TODO:runQuery"$/;"	fi	line:184
safeHead	src/Language/LLVC/Utils.hs	/^safeHead :: a -> [a] -> a$/;"	ft	line:84
safeHead	src/Language/LLVC/Utils.hs	/^safeHead def []    = def$/;"	fi	line:85
safeReadFile	src/Language/LLVC/Utils.hs	/^safeReadFile :: FilePath -> IO (Either String String)$/;"	ft	line:75
safeReadFile	src/Language/LLVC/Utils.hs	/^safeReadFile f = (Right <$> readFile f) `catch` handleIO f$/;"	fi	line:76
sanitizeChar	src/Language/LLVC/Smt.hs	/^sanitizeChar :: Char -> Char $/;"	ft	line:129
sanitizeChar	src/Language/LLVC/Smt.hs	/^sanitizeChar '%' = '_'$/;"	fi	line:130
sanitizeVar	src/Language/LLVC/Smt.hs	/^sanitizeVar :: Var -> Smt $/;"	ft	line:125
sanitizeVar	src/Language/LLVC/Smt.hs	/^sanitizeVar ('%':cs) = 'r' : (sanitizeChar <$> cs) $/;"	fi	line:126
say	src/Language/LLVC/Smt.hs	/^say :: UX.Text -> VC$/;"	ft	line:176
say	src/Language/LLVC/Smt.hs	/^say s = VC [ Say s ]$/;"	fi	line:177
sc	src/Language/LLVC/Parse.hs	/^sc :: Parser ()$/;"	ft	line:254
sc	src/Language/LLVC/Parse.hs	/^sc = L.space (void spaceChar) lineCmnt blockCmnt$/;"	fi	line:255
selectP	src/Language/LLVC/Parse.hs	/^selectP :: Parser BareExpr $/;"	ft	line:155
selectP	src/Language/LLVC/Parse.hs	/^selectP = do $/;"	fi	line:156
sigIntHex	src/Language/LLVC/Smt.hs	/^sigIntHex :: Integer -> Type -> Smt $/;"	ft	line:94
sigIntHex	src/Language/LLVC/Smt.hs	/^sigIntHex n t     = M.lookupDefault res (n, t) convTable $/;"	fi	line:95
smtId	src/Language/LLVC/Parse.hs	/^smtId :: Parser (String, SourceSpan)$/;"	ft	line:335
smtId	src/Language/LLVC/Parse.hs	/^smtId = lexeme (p >>= checkId)$/;"	fi	line:336
smtRead	src/Language/LLVC/Smt.hs	/^smtRead :: Context -> IO Response$/;"	ft	line:201
smtRead	src/Language/LLVC/Smt.hs	/^smtRead me = strResponse . T.unpack <$> smtReadRaw me$/;"	fi	line:202
smtReadRaw	src/Language/LLVC/Smt.hs	/^smtReadRaw       :: Context -> IO T.Text$/;"	ft	line:212
smtReadRaw	src/Language/LLVC/Smt.hs	/^smtReadRaw me    = {-# SCC "smtReadRaw" #-} TIO.hGetLine (ctxCin me)$/;"	fi	line:213
smtWrite	src/Language/LLVC/Smt.hs	/^smtWrite :: Context -> T.Text -> IO ()$/;"	ft	line:198
smtWrite	src/Language/LLVC/Smt.hs	/^smtWrite me !s = smtWriteRaw me s$/;"	fi	line:199
smtWriteRaw	src/Language/LLVC/Smt.hs	/^smtWriteRaw      :: Context -> T.Text -> IO ()$/;"	ft	line:207
smtWriteRaw	src/Language/LLVC/Smt.hs	/^smtWriteRaw me !s = {-# SCC "smtWriteRaw" #-} do$/;"	fi	line:208
someFunc	src/Lib.hs	/^someFunc :: IO ()$/;"	ft	line:5
someFunc	src/Lib.hs	/^someFunc = putStrLn "someFunc"$/;"	fi	line:6
sourceSpan	src/Language/LLVC/UX.hs	/^  sourceSpan :: a -> SourceSpan$/;"	ft	line:55
spanFile	src/Language/LLVC/UX.hs	/^spanFile :: SourceSpan -> FilePath$/;"	ft	line:110
spanFile	src/Language/LLVC/UX.hs	/^spanFile = sourceName . ssBegin$/;"	fi	line:111
spanInfo	src/Language/LLVC/UX.hs	/^spanInfo :: SourceSpan -> (FilePath, Int, Int, Int, Int)$/;"	ft	line:89
spanInfo	src/Language/LLVC/UX.hs	/^spanInfo s = (f s, l1 s, c1 s, l2 s, c2 s)$/;"	fi	line:90
ssBegin	src/Language/LLVC/UX.hs	/^  { ssBegin :: !SourcePos$/;"	c_a	line:64
ssEnd	src/Language/LLVC/UX.hs	/^  , ssEnd   :: !SourcePos$/;"	c_a	line:65
stmtP	src/Language/LLVC/Parse.hs	/^stmtP :: Parser BareStmt $/;"	ft	line:95
stmtP	src/Language/LLVC/Parse.hs	/^stmtP $/;"	fi	line:96
strResponse	src/Language/LLVC/Smt.hs	/^strResponse :: String -> Response $/;"	ft	line:204
strResponse	src/Language/LLVC/Smt.hs	/^strResponse = undefined $/;"	fi	line:205
stretch	src/Language/LLVC/Parse.hs	/^stretch :: (Monoid a) => [Expr a] -> a$/;"	ft	line:350
stretch	src/Language/LLVC/Parse.hs	/^stretch = mconcat . fmap getLabel$/;"	fi	line:351
subst	src/Language/LLVC/Types.hs	/^subst :: (UX.Located a) => [(Var, Arg a)] -> Pred -> Pred$/;"	ft	line:305
subst	src/Language/LLVC/Types.hs	/^subst su             = go $/;"	fi	line:306
symbol	src/Language/LLVC/Parse.hs	/^symbol :: String -> Parser String$/;"	ft	line:261
symbol	src/Language/LLVC/Parse.hs	/^symbol = L.symbol sc$/;"	fi	line:262
tLit	src/Language/LLVC/Types.hs	/^tLit :: TypedArg a -> TypedArg a $/;"	ft	line:204
tLit	src/Language/LLVC/Types.hs	/^tLit (t, ELit n l) = (t, ETLit n t l) $/;"	fi	line:205
toSmt	src/Language/LLVC/Smt.hs	/^  toSmt :: a -> Smt $/;"	ft	line:58
toSmts	src/Language/LLVC/Smt.hs	/^toSmts :: (ToSmt a) => [a] -> Smt$/;"	ft	line:113
toSmts	src/Language/LLVC/Smt.hs	/^toSmts = unwords . fmap toSmt$/;"	fi	line:114
traceShow	src/Language/LLVC/Utils.hs	/^traceShow :: (Show a) => String -> a -> a$/;"	ft	line:81
traceShow	src/Language/LLVC/Utils.hs	/^traceShow msg x = trace (printf "TRACE: %s = %s" msg (show x)) x$/;"	fi	line:82
trim	src/Language/LLVC/Utils.hs	/^trim :: String -> String$/;"	ft	line:46
trim	src/Language/LLVC/Utils.hs	/^trim = f . f  where f = reverse . dropWhile isSpace$/;"	fi	line:47
trimEnd	src/Language/LLVC/Utils.hs	/^trimEnd :: String -> String$/;"	ft	line:49
trimEnd	src/Language/LLVC/Utils.hs	/^trimEnd = reverse . dropWhile isSpace . reverse  $/;"	fi	line:50
typeP	src/Language/LLVC/Parse.hs	/^typeP :: Parser Type $/;"	ft	line:187
typeP	src/Language/LLVC/Parse.hs	/^typeP =  (rWord "float" >> return Float)  $/;"	fi	line:188
typedArgP	src/Language/LLVC/Parse.hs	/^typedArgP :: Parser BareTypedArg  $/;"	ft	line:163
typedArgP	src/Language/LLVC/Parse.hs	/^typedArgP = (,) <$> typeP <*> argP$/;"	fi	line:164
varP	src/Language/LLVC/Parse.hs	/^varP :: Text -> Parser Var$/;"	ft	line:327
varP	src/Language/LLVC/Parse.hs	/^varP s = fst <$> identifier s $/;"	fi	line:328
vcFun	src/Language/LLVC/Verify.hs	/^vcFun :: (Located a) => Env -> FnDef a -> FnBody a -> VC $/;"	ft	line:26
vcFun	src/Language/LLVC/Verify.hs	/^vcFun env fd fb = comment    ("VC for: " ++  fnName fd)$/;"	fi	line:27
vcStmt	src/Language/LLVC/Verify.hs	/^vcStmt :: (Located a) => Env -> Stmt a -> VC $/;"	ft	line:39
vcStmt	src/Language/LLVC/Verify.hs	/^vcStmt _ (SAssert p l) $/;"	fi	line:40
vcs	src/Language/LLVC/Verify.hs	/^vcs :: (Located a) => Program a -> [(Var, VC)] $/;"	ft	line:17
vcs	src/Language/LLVC/Verify.hs	/^vcs p   = [ (f, vcFun env fd fb)$/;"	fi	line:19
whole	src/Language/LLVC/Parse.hs	/^whole :: Parser a -> Parser a$/;"	ft	line:250
whole	src/Language/LLVC/Parse.hs	/^whole p = sc *> p <* eof$/;"	fi	line:251
withBracket	src/Language/LLVC/Smt.hs	/^withBracket :: VC -> VC $/;"	ft	line:166
withBracket	src/Language/LLVC/Smt.hs	/^withBracket vc = push <> vc <> pop $/;"	fi	line:167
withSpan	src/Language/LLVC/Parse.hs	/^withSpan :: Parser a -> Parser (a, SourceSpan)$/;"	ft	line:320
withSpan	src/Language/LLVC/Parse.hs	/^withSpan p = do$/;"	fi	line:321
withSpan'	src/Language/LLVC/Parse.hs	/^withSpan' :: Parser (SourceSpan -> a) -> Parser a$/;"	ft	line:313
withSpan'	src/Language/LLVC/Parse.hs	/^withSpan' p = do$/;"	fi	line:314
writeLoud	src/Language/LLVC/Utils.hs	/^writeLoud :: String -> IO ()$/;"	ft	line:69
writeLoud	src/Language/LLVC/Utils.hs	/^writeLoud s = whenLoud $ putStrLn s >> hFlush stdout$/;"	fi	line:70
writeQuery	src/Language/LLVC/Smt.hs	/^writeQuery :: FilePath -> VC -> IO () $/;"	ft	line:45
writeQuery	src/Language/LLVC/Smt.hs	/^writeQuery f vc = do $/;"	fi	line:46
